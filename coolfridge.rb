require 'dotenv/load'

require 'sinatra'
require 'sinatra/json'
require 'sinatra/cors'

require 'cloudinary'
require 'cloudinary/uploader'
require 'cloudinary/utils'

require 'pp'

set :bind, '0.0.0.0'

set :allow_origin,   '*'
set :allow_methods,  'GET,HEAD,POST'
set :allow_headers,  'content-type,if-modified-since'
set :expose_headers, 'location,link'

helpers do
  def base_url
    @base_url ||= "#{request.env['rack.url_scheme']}://#{request.env['HTTP_HOST']}"
  end
end

get '/photo' do
begin
  img = (params[:pic] || 'fruit0.jpg')
  img_path = "./public/#{img}"
  if (img =~ /fruit(.*)[.]jpg/i)
    img_id  = $1.to_i
  else
    img_id = 0
  end
  # puts base_url
  # puts "Calling cloudinary for #{img}..." + Time.now.to_s

  if Cloudinary.config.api_key.blank?
    require_relative './config'
  end
   
  initial_response = Cloudinary::Uploader.upload img_path, :tags => 'basic_sample', :categorization => 'aws_rek_tagging'

  # public_id for the uploaded image is generated by Cloudinary's service.
  public_id = initial_response['public_id']
  front_url = initial_response["url"].sub(/upload.*/,'upload')
   
  ne_preset = "e_sharpen,e_improve,e_auto_contrast,q_auto,$rows_2,$cols_2,$hIndex_0,$vIndex_0,$tilewidth_iw_div_$cols,$tileheight_ih_div_$rows/w_$tilewidth,h_$tileheight,c_crop,x_$tilewidth_mul_$hIndex,y_$tileheight_mul_$vIndex"
  nw_preset = "e_sharpen,e_improve,e_auto_contrast,q_auto,$rows_2,$cols_2,$hIndex_1,$vIndex_0,$tilewidth_iw_div_$cols,$tileheight_ih_div_$rows/w_$tilewidth,h_$tileheight,c_crop,x_$tilewidth_mul_$hIndex,y_$tileheight_mul_$vIndex"
  se_preset = "e_sharpen,e_improve,e_auto_contrast,q_auto,$rows_2,$cols_2,$hIndex_0,$vIndex_1,$tilewidth_iw_div_$cols,$tileheight_ih_div_$rows/w_$tilewidth,h_$tileheight,c_crop,x_$tilewidth_mul_$hIndex,y_$tileheight_mul_$vIndex"
  sw_preset = "e_sharpen,e_improve,e_auto_contrast,q_auto,$rows_2,$cols_2,$hIndex_1,$vIndex_1,$tilewidth_iw_div_$cols,$tileheight_ih_div_$rows/w_$tilewidth,h_$tileheight,c_crop,x_$tilewidth_mul_$hIndex,y_$tileheight_mul_$vIndex"
   
  cropped_image_responses = []
  [ne_preset, nw_preset, se_preset, sw_preset].each do |preset|
    new_url = "#{front_url}/#{preset}/#{public_id}.jpg"
    resp = Cloudinary::Uploader.upload(new_url, :tags => "basic_sample", :categorization => "aws_rek_tagging")
    data = resp["info"]["categorization"]["aws_rek_tagging"]["data"].first
    cropped_image_responses << {id: resp['public_id'], url: resp['url'], name: data['tag'], score: data['confidence'], timestamp: Time.now.to_s}
  end
  # puts "Cloudinary replied for #{img}..." + Time.now.to_s
  output = cropped_image_responses
rescue
  output = [{:error => $!.to_s}]
end
  json(output)
end

get '/picture' do
begin
  img = (params[:pic] || 'fruit0.jpg')
  img_path = "./public/#{img}"
  if (img =~ /fruit(.*)[.]jpg/i)
    img_id  = $1.to_i
  else
    img_id = 0
  end

  cmd = %Q(curl -s -X POST -u "apikey:#{ENV['WATSON_API_KEY']}" --form "images_file=@#{img_path}" "https://gateway.watsonplatform.net/visual-recognition/api/v3/classify?version=2018-03-19")
  # puts cmd

  t1 = Time.now
  str = `#{cmd}`
  t2 = Time.now
  # puts "watson is back in #{(t2-t1)} seconds!"

  json_obj = JSON.parse(str)

  hash = json_obj.to_h
  # pp hash;puts

  classes = Array(hash["images"]&.first["classifiers"]&.first["classes"])
  last    = classes.select{|h1| h1["type_hierarchy"]}.sort_by{|h| h["score"]}.last
  img_url = base_url + '/' + img
  if last
    output = {name: last["class"], url: img_url, date: Time.now.to_s, id: img_id, score: last["score"]}
  else
    output = {name: img, url: img_url, date: Time.now.to_s, id: img_id, pct: 0.999}
  end
  #pp output

rescue
   output = {error: $!.to_s}
end
  json([output])
end
